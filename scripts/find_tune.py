"""
Script to find the tune; drives xboa DPhiTuneFinder (FFT was making large side
bands which looked non-physical)
"""

import glob
import json
import sys
import math
import os
import shutil
import ROOT
from opal_tracking import OpalTracking
import xboa.common as common
from xboa.hit import Hit
from xboa.algorithms.tune import FFTTuneFinder
from xboa.algorithms.tune import DPhiTuneFinder

class Tune(object):
    def __init__(self, probe_file_name, closed_orbits_file_name, energy_min = None, energy_max = None):
        """
        Find the tune. 

        -probe_file_name: name of a PROBE file from OPAL output, or None. If file_name
                    is specified, use that file_name in order to calculate tunes
                    (and generate plots), otherwise generate a new one by
                    tracking.
        -closed_orbits_file_name: name of a file containing closed orbits,
                    generated by e.g. 
        """
        self.closed_orbits_cached = None # filled by _load_closed_orbits
        self.tmp_dir = None
        self.unique_id = 2
        self.just_plot = probe_file_name != None
        if self.just_plot:
            self.opal = "/bin/echo" # disables the tune calculation
        else:
            self.opal = os.path.expandvars("${OPAL_EXE_PATH}/opal")
            if "OPAL_EXE_PATH" in self.opal:
                raise RuntimeError("${OPAL_EXE_PATH} environment variable "+\
                    "not set; should point to the directory where opal "+\
                    "executable is found.")
        self.lattice_src = "lattices/KurriMainRingTuneComparison/"+\
                           "KurriMainRingTuneComparison.in"
        self.lattice = "/Tune.tmp"
        self.beam_file = "/disttest.dat"
        self.log_file = "/log"
        if self.just_plot:
            self.output_filename = file_name
        else:
            self.output_filename = "PROBE*.loss"
        self._load_closed_orbits(closed_orbits_file_name)
        self.nturns = 100.1
        self.step_size = 10.
        self.poly_order = 1
        self.smooth_order = 1
        self.delta_x = 1.
        self.delta_y = 1.
        self.string_id = "_nturns="+str(self.nturns)+"_stepsize="+\
              str(self.step_size)+"_poly_order="+str(self.poly_order)+\
              "_smooth_order="+str(self.smooth_order)+"_id="+str(self.unique_id)
        self.output = "tunes"+self.string_id+".out"
        self.energy_min, self.energy_max = energy_min, energy_max

    def find_tune_dphi(self):
        """
        Algorithm is to just calculate the turn-by-turn phase advance; this is
        done by evolving turn-by-turn the track; calculating a matched ellipse
        by looking at tracking output; transforming the ellipse into a circle
        using LU decomposition; then calculating the angle advanced.
        """
        fout = open(self.output, "w")
        index = 0
        for energy, position in sorted(self.closed_orbits_cached.iteritems()):
            if self.energy_min != None and self.energy_max != None:
                if energy < self.energy_min or energy > self.energy_max:
                    continue
            index += 1
            if index > 2:
                ROOT.gROOT.SetBatch(True)
            print "Finding tune at", energy, "MeV and closed orbit x=", position, "mm"
            self.co_x = position
            tune_info = {
                "energy":energy,
                "nturns":self.nturns,
                "stepsize":self.step_size,
                "poly_order":self.poly_order,
                "smooth_order":self.smooth_order,
            }
            for axis1, axis2, delta1, delta2 in [("x", "px", self.delta_x, 0.),
                                                 ("y", "py", self.delta_y, 0.)]:
                hit = self._reference(energy)
                hit["x"] = position
                self._temp_dir()
                common.substitute(
                    self.lattice_src, 
                    self.tmp_dir+self.lattice, {
                        "__energy__":energy,
                        "__nturns__":self.nturns,
                        "__beamfile__":self.tmp_dir+self.beam_file,
                        "__stepsize__":self.step_size,
                        "__poly_order__":self.poly_order,
                        "__smooth_order__":self.smooth_order,
                })
                tracking = OpalTracking(self.tmp_dir+self.lattice,
                                        self.tmp_dir+self.beam_file,
                                        self._reference(energy),
                                        self.output_filename,
                                        self.opal,
                                        self.tmp_dir+self.log_file)
                finder = DPhiTuneFinder()
                finder.run_tracking(axis1, axis2, delta1, delta2, hit, tracking)
                for track_index, track in enumerate(tracking.last):
                    print 'Track', track_index, 'of', len(tracking.last), \
                          'with', len(track), 'hits'
                    for hit in track:
                        print '    ', hit['t'], 'polar:', math.atan2(hit['y'], \
                              hit['x']), (hit['y']**2+hit['x']**2)**0.5, \
                              'cart:', hit['x'], hit['y'], hit['z']
                tune = finder.get_tune(self.nturns/10.)
                tune_info[axis1+"_tune"] = tune
                tune_info[axis1+"_tune_error"] = finder.tune_error
                tune_info[axis1+"_signal"] = zip(finder.u, finder.up)
            for key in sorted(tune_info.keys()):
                if "signal" not in key:
                    print "   ", key, tune_info[key]
            print >> fout, json.dumps(tune_info)
            fout.flush()

    def _temp_dir(self):
        """Make a temporary directory for tune calculation"""
        self.tmp_dir = "tmp/tune/"+str(self.unique_id)+"/"
        if self.just_plot:
            return
        try:
            shutil.rmtree(self.tmp_dir)
        except OSError:
            pass
        os.makedirs(self.tmp_dir)

    def _load_closed_orbits(self, filename):
        """Load closed orbits from a json file"""
        fin = open(filename)
        closed_orbits = [json.loads(line) for line in fin.readlines()]
        closed_orbits_energy = [orbit[0] for orbit in closed_orbits]
        closed_orbits_x = [orbit[1:][0][0] for orbit in closed_orbits]
        closed_orbits_dict = dict(zip(closed_orbits_energy, closed_orbits_x))
        self.closed_orbits_cached = closed_orbits_dict

    def _reference(self, energy):
        """Generate a reference particle"""
        hit_dict = {}
        hit_dict["pid"] = 2212
        hit_dict["mass"] = common.pdg_pid_to_mass[2212]
        hit_dict["charge"] = 1
        hit_dict["x"] = 4600.
        hit_dict["kinetic_energy"] = energy
        return Hit.new_from_dict(hit_dict, "pz")

    def _print_canvas(self, canvas, axis, name, energy):
        """Print a canvas"""
        name = "plots/"+axis+"_"+name+"_energy="+str(energy)+self.string_id
        for format in ["png", "root"]:
            canvas.Print(name+"."+format)

def main():
    tune = Tune(None,
                "lattices/KurriMainRingTuneComparison/closed_orbits.ref",
                10.99,
                15.01)
    tune.find_tune_dphi()

if __name__ == "__main__":
    main()
    print "Finished"
    raw_input()










